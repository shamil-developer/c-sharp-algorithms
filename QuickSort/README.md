# Быстрая сортировка

- `QuickSort`

### Этапы алгоритма:

1. Запускаем рекурсивный метод
2. Базовый случай - массив из одного элемента или пуст, ничего не делаем
3. Если случай не базовый то попадаем в рекурсивный случай, где массив больше чем из одного элемента.
4. Берем опорный элемент(pivot), и создаем два массива, в первом те значения что меньше опарного в правом те что больше
5. Рекурсивный вызов функции на эти два массива

### Оценки сложности алгоритма:

Лучший случай:

$$
O(n log n)
$$

Худший случай:

$$
O(n²)
$$

### Почему мы выбираем быструю сортировку нежили сортировку слиянием ?

У быстрой сортировки константа меньше, чем у сортировки слиянием, поэтому, несмотря на то что оба алгоритма характеризуются временем O(n log n), быстрая сортировка работает быстрее. А на практике быстрая сортировка работает быстрее, потому что средний случай встречается намного чаще худшего.

### Средний и худший случай быстрой сортировки

1. Худший случай когда опорный элемент или самое меньшее значение или самое больше, в итоге в рекурсию уходит большое массив что увеличивает количество попаданий в рекурсивный случай
2. Средний случае когда опорный элемент это среднее число и в итоге попаданий в рекурсивный случай становиться меньше.

### Код на языке c#

```c#
public static void QuickSort(this int[] array)
{
    QuickSort(array, 0, array.Length - 1);
}
private static void QuickSort(int[] array, int l, int r)
{
    if (l < r)
    {
        int pivot = Partition(array, l, r);

        QuickSort(array, l, pivot - 1);
        QuickSort(array, pivot + 1, r);
    }
}
private static int Partition(int[] arr, int left, int right)
{
    int pivot = arr[right];
    int i = left - 1;
    for (int j = left; j < right; j++)
    {
        if (arr[j] <= pivot)
        {
            i++;
            (arr[j], arr[i]) = (arr[i], arr[j]);
        }
    }
    (arr[right], arr[i + 1]) = (arr[i + 1], arr[right]);
    return i + 1;
}
```
